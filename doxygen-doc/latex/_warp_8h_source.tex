\hypertarget{_warp_8h_source}{}\doxysection{Warp.\+h}
\label{_warp_8h_source}\index{Warp.h@{Warp.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include "{}CoreLayer/Geometry/Geometry.h"{}}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include "{}Common.h"{}}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{keyword}{static}  \textcolor{keywordtype}{double} TentInverse(\textcolor{keywordtype}{double} x)\{}
\DoxyCodeLine{15     \textcolor{keywordflow}{if}(x<=.5f)}
\DoxyCodeLine{16         \textcolor{keywordflow}{return} std::sqrt(2*x)-\/1;}
\DoxyCodeLine{17     \textcolor{keywordflow}{return}  1-\/ std::sqrt(2-\/2*x);}
\DoxyCodeLine{18 \}}
\DoxyCodeLine{19 \textcolor{keyword}{inline}   \mbox{\hyperlink{struct_t_point2}{Point2d}} SquareToTent(\textcolor{keyword}{const} \mbox{\hyperlink{struct_t_point2}{Point2d}} \&sample) \{}
\DoxyCodeLine{20     \mbox{\hyperlink{struct_t_point2}{Point2d}}  res(TentInverse(sample[0]), TentInverse(sample[1]));}
\DoxyCodeLine{21     \textcolor{keywordflow}{return}  res;}
\DoxyCodeLine{22 \textcolor{comment}{//    throw NoriException("{}SquareToTent() is not yet implemented!"{});}}
\DoxyCodeLine{23 \}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{keyword}{inline} \textcolor{keywordtype}{double} SquareToTentPdf(\textcolor{keyword}{const} \mbox{\hyperlink{struct_t_point2}{Point2d}} \&p) \{}
\DoxyCodeLine{26     \textcolor{keywordflow}{return} (1.0-\/std::abs(p[0])) * (1.0-\/std::abs(p[1]));}
\DoxyCodeLine{27 \}}
\DoxyCodeLine{28 }
\DoxyCodeLine{29 \textcolor{keyword}{inline} \mbox{\hyperlink{struct_t_vector3}{Vec3d}} SquareToUniformSphere(\textcolor{keyword}{const} \mbox{\hyperlink{struct_t_point2}{Point2d}} \&sample) \{}
\DoxyCodeLine{30     \textcolor{keywordtype}{float} z = 1 -\/ 2 * sample[0];}
\DoxyCodeLine{31     \textcolor{keywordtype}{float} r = std::sqrt(std::max((\textcolor{keywordtype}{float} )0, (\textcolor{keywordtype}{float})1 -\/ z * z));}
\DoxyCodeLine{32     \textcolor{keywordtype}{float} phi = 2 * M\_PI * sample[1];}
\DoxyCodeLine{33     \textcolor{keywordflow}{return} \{r * std::cos(phi), r * std::sin(phi), z\};}
\DoxyCodeLine{34 \}}
\DoxyCodeLine{35 }
\DoxyCodeLine{36 \textcolor{keyword}{inline}  \textcolor{keywordtype}{float} SquareToUniformSpherePdf(\textcolor{keyword}{const} \mbox{\hyperlink{struct_t_vector3}{Vec3d}} \&v) \{}
\DoxyCodeLine{37     \textcolor{keywordflow}{return} 0.25f*INV\_PI;}
\DoxyCodeLine{38 \}}
\DoxyCodeLine{39 }
\DoxyCodeLine{40 \textcolor{keyword}{inline}  \mbox{\hyperlink{struct_t_vector3}{Vec3d}} SquareToUniformHemisphere(\textcolor{keyword}{const} \mbox{\hyperlink{struct_t_point2}{Point2d}} \&sample) \{}
\DoxyCodeLine{41     \textcolor{keywordtype}{float} z = 1 -\/ 2 * sample[0];}
\DoxyCodeLine{42     \textcolor{keywordtype}{float} r = std::sqrt(std::max((\textcolor{keywordtype}{float} )0, (\textcolor{keywordtype}{float})1 -\/ z * z));}
\DoxyCodeLine{43     \textcolor{keywordtype}{float} phi = 2 * M\_PI * sample[1];}
\DoxyCodeLine{44     \textcolor{keywordflow}{return} \{r * std::cos(phi), r * std::sin(phi), std::abs(z)\};}
\DoxyCodeLine{45 \}}
\DoxyCodeLine{46 }
\DoxyCodeLine{47 \textcolor{keyword}{inline} \textcolor{keywordtype}{float} SquareToUniformHemispherePdf(\textcolor{keyword}{const} \mbox{\hyperlink{struct_t_vector3}{Vec3d}} \&v) \{}
\DoxyCodeLine{48     \textcolor{keywordflow}{return} v[2] >=0 ? 0.5f * INV\_PI : .0f;}
\DoxyCodeLine{49 \}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51 \textcolor{keyword}{inline}  \mbox{\hyperlink{struct_t_vector3}{Vec3d}} SquareToCosineHemisphere(\textcolor{keyword}{const} \mbox{\hyperlink{struct_t_point2}{Point2d}} \&sample) \{}
\DoxyCodeLine{52     \textcolor{keywordtype}{float} z=sqrt(1-\/sample.x);}
\DoxyCodeLine{53     \textcolor{keywordtype}{float} phi=sample.y*2*M\_PI;}
\DoxyCodeLine{54 }
\DoxyCodeLine{55     \textcolor{keywordflow}{return} \{sqrt(sample.x)* cos(phi),sqrt(sample.x)*sin(phi),z\};}
\DoxyCodeLine{56 \}}
\DoxyCodeLine{57 }
\DoxyCodeLine{58 \textcolor{keyword}{inline}  \textcolor{keywordtype}{float} SquareToCosineHemispherePdf(\textcolor{keyword}{const} \mbox{\hyperlink{struct_t_vector3}{Vec3d}} \&v) \{}
\DoxyCodeLine{59     \textcolor{keywordflow}{return} v[2] >=0 ? v.z * INV\_PI : .0f;}
\DoxyCodeLine{60 \}}
\DoxyCodeLine{61 \textcolor{comment}{//}}
\DoxyCodeLine{62 \textcolor{keyword}{inline}  \mbox{\hyperlink{struct_t_vector3}{Vec3d}} SquareToBeckmann(\textcolor{keyword}{const} \mbox{\hyperlink{struct_t_point2}{Point2d}} \&sample,\textcolor{keywordtype}{double} alpha) \{}
\DoxyCodeLine{63     \textcolor{keyword}{auto} tan2theta= -\/alpha*alpha*log( sample.x );}
\DoxyCodeLine{64     \textcolor{keyword}{auto} cosTheta=sqrt(1/(1+tan2theta));}
\DoxyCodeLine{65     \textcolor{keyword}{auto} sinTheta= sqrt(1-\/cosTheta*cosTheta);}
\DoxyCodeLine{66     \textcolor{keyword}{auto} phi=sample.y * 2 * M\_PI;}
\DoxyCodeLine{67     \mbox{\hyperlink{struct_t_vector3}{Vec3d}} t1= \mbox{\hyperlink{struct_t_vector3}{Vec3d}}(sinTheta*cos(phi), sinTheta*sin(phi),cosTheta);}
\DoxyCodeLine{68     \textcolor{keywordflow}{return} t1;}
\DoxyCodeLine{69 \}}
\DoxyCodeLine{70 \textcolor{comment}{//}}
\DoxyCodeLine{71 \textcolor{keyword}{inline}  \textcolor{keywordtype}{float} SquareToBeckmannPdf(\textcolor{keyword}{const} \mbox{\hyperlink{struct_t_vector3}{Vec3d}} \&m, \textcolor{keywordtype}{double} alpha) \{}
\DoxyCodeLine{72     \textcolor{keywordflow}{if}(m.z<=0)}
\DoxyCodeLine{73         \textcolor{keywordflow}{return} 0.0f;}
\DoxyCodeLine{74     \textcolor{keyword}{auto} cosTheta=m.z;}
\DoxyCodeLine{75     \textcolor{keyword}{auto} sinTheta=sqrt(1-\/cosTheta*cosTheta);}
\DoxyCodeLine{76     \textcolor{keyword}{auto} tan2Theta=(sinTheta* sinTheta)/(cosTheta*cosTheta);}
\DoxyCodeLine{77     \textcolor{keywordtype}{float} azimuthal =   INV\_PI;}
\DoxyCodeLine{78     \textcolor{keywordtype}{float} longitudinal = exp(-\/tan2Theta/(alpha*alpha))  / (alpha*alpha*pow(cosTheta,3));}
\DoxyCodeLine{79     \textcolor{keywordflow}{return} azimuthal * longitudinal;}
\DoxyCodeLine{80 \}}

\end{DoxyCode}
